---
title: 2.3 Working with SQLite
layout: module
nav_order: 0203
summary: >-
  SQLite provides a fast, lightweight alternative to a full SQL database which we can use for local development and testing. In this module, we'll learn how to configure and use SQLite with EF Core so we can create fast, stable tests around code which relies on application data.
examples: examples/203/rockaway/
typora-root-url: .
typora-copy-images-to: ./images
---

In the last module, we set up a SQL Server database, added EF Core to our application, and wired up an endpoint that displays a list of artists from our database.

It works -- but all our tests are failing, which is probably bad.

In this module, we'll see how to configure our application so we can run end-to-end tests of our web application, using a lightweight, standalone database that runs as part of our test code.

## Introducing SQLite

> SQLite is a C-language library that implements a [small](https://sqlite.org/footprint.html), [fast](https://sqlite.org/fasterthanfs.html), [self-contained](https://sqlite.org/selfcontained.html), [high-reliability](https://sqlite.org/hirely.html), [full-featured](https://sqlite.org/fullsql.html), SQL database engine. SQLite is the [most used](https://sqlite.org/mostdeployed.html) database engine in the world. SQLite is built into all mobile phones and most computers and comes bundled inside countless other applications that people use every day.
>
> *from [https://sqlite.org/](https://sqlite.org/)*

In other words, SQLite is a tiny database engine that doesn't use a server: it runs in the same process as our application code, which makes it perfect for running isolated tests that still need to connect to some sort of database.

Let's see what we need to do to get our test code using SQLite instead of SQL Server.

## Using SQLite for Application Tests

First, we're going to install the SQLite provider for Entity Framework Core - **remember to install this into the Rockaway.WebApp.Tests project, not the main WebApp project**

```
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
```

Next, we're going to wire up our `TestFactory` to use SQLite instead of connecting to a real SQL server instance.

We'll wrap up our Sqlite configuration code in a `TestDatabase` class:

**Rockaway.WebApp.Tests/Data/TestDatabase.cs**

```csharp
namespace Rockaway.WebApp.Tests.Data; 

class TestDatabase {
	public static readonly ILoggerFactory ConsoleLoggerFactory
		= LoggerFactory.Create(builder => builder.AddConsole());

	public static async Task<RockawayDbContext> CreateAsync(string? dbName = null) {
		dbName ??= Guid.NewGuid().ToString();
		var dbContext = Connect(dbName);
		await dbContext.Database.EnsureCreatedAsync();
		return dbContext;
	}

	public static RockawayDbContext Connect(string dbName) {
		var connectionString = $"Data Source={dbName};Mode=Memory;Cache=Shared";
		var sqliteConnection = new SqliteConnection(connectionString);
		sqliteConnection.Open();
		var options = new DbContextOptionsBuilder<RockawayDbContext>()
			.UseSqlite(sqliteConnection)
			.UseLoggerFactory(ConsoleLoggerFactory)
			.Options;
		return new(options);
	}
}
```

> Notice that we're specifying `Mode=Memory` in our Sqlite connection string. This means we'll use a unique, temporary, in-memory database for every connection, and each database will be discarded as soon as there are no more open connections.

Now, we can modify our `TestFactory` to replace the "real" DbContext with our Sqlite version:

```csharp
{% include_relative {{ page.examples }}Rockaway.WebApp.Tests/TestFactory.cs %}
```

We need to make one more change here.

The vast majority of database operations generated by EF Core will work with SQLite or SQL Server with no modifications, but our DatabaseVersion method uses `@@VERSION`, which is a Microsoft SQL Server feature that doesn't exist in SQLite:

```csharp
// A helper property which we'll use to test the connection and return the server version.
public string ServerVersion => Database.SqlQueryRaw<string>($"SELECT {DbVersionExpression} as Value").Single();

private string DbVersionExpression {
    get {
        if (Database.IsSqlServer()) return "@@VERSION";
        if (Database.IsSqlite()) return ("sqlite_version()");
        throw new Exception("Unsupported database provider");
    }
}
```

## Local Development Using SQLite

If we can run our tests against SQLite, can we run our actual application with SQLite so we don't have to run a Docker image?

Sure we can, with a bit of ingenuity. We can use a configuration value to switch between SQLite and SQL Server, and set up the `DbContext` accordingly.

SQLite can run either as a disposable in-memory database, or as a persistent database backed by a .db file.

If you're running in in-memory mode, then explicitly open a connection to your database during app initialization and don't close it; this ensures the database remains available for as long as your application is running:
```csharp
var conn = new SqliteConnection("Data Source=rockaway;Mode=Memory;Cache=Shared");
await conn.OpenAsync();
```

If you're using in-memory mode, you start with a completely empty database every time, so you'll need to create the schema and populate your database each time you run your app. Calling `Database.EnsureCreated()` will create the schema and insert any data defined via the `HasData()` methods in your `DbContext`:

```csharp
var app = builder.Build();
if (databaseProvider == "sqlite") {
	using var scope = app.Services.CreateScope();
	var db = scope.ServiceProvider.GetService<RockawayDbContext>()!;
	lock (db) db.Database.EnsureCreated();
}

// other app initialisation code happens here
app.Run();
```

 To run SQLite in filesystem mode, provide the path to the file where you want to store your data. If it doesn't exist, `SQLite` will create it for you:

```csharp
var conn = new SqliteConnection("Data Source=D:\\path\\to\\rockaway.db");
```

To keep your filesystem database in sync, you can either apply database migrations manually. Note that you still need to specify the database mode, but you need to put an extra `--` in the command line or the `dotnet ef` tooling will try to parse `database=sqlite` as a migration parameter and throw an error:

```
dotnet ef database update -- database-sqlite
```

Alternatively, you can call `db.Database.Migrate()` during application startup:

```csharp
var app = builder.Build();
if (databaseProvider == "sqlite") {
	using var scope = app.Services.CreateScope();
	var db = scope.ServiceProvider.GetService<RockawayDbContext>()!;
	db.Database.Migrate();
}
```

SQLite with in-memory mode and `EnsureCreated()` provides a really simple way to get the application up and running, play around with it, see what it can do. It's also ideal for frontend development work where you're focused on layouts and user interactions and not making lots of changes to the underlying application logic and business rules.

{: .warning }
You can't mix `EnsureCreated` and migrations in the same database -- and you shouldn't want to. `EnsureCreated()` is intended for use in testing and local development scenarios; it's like teleporting directly to the latest known state of the data model. Migrations are designed to help you manage the state of a production database over an application's entire lifecycle, which could be many, many years.

Here's the complete listing for `Program.cs` with support for running against either SQL Server or SQLite:

**Rockaway.WebApp/Program.cs:**

```csharp
{% include_relative {{ page.examples }}Rockaway.WebApp/Program.cs %}
```

