---
title: 2.3 Working with SQLite
layout: module
nav_order: 0203
summary: >-
  SQLite provides a fast, lightweight alternative to a full SQL database which we can use for local development and testing. In this module, we'll learn how to configure and use SQLite with EF Core so we can create fast, stable tests around code which relies on application data.
examples: examples/203/rockaway/
typora-root-url: .
typora-copy-images-to: ./images
previous: mwnet202
complete: mwnet203
---

In the last module, we set up a SQL Server database, added EF Core to our application, and wired up an endpoint that displays a list of artists from our database.

It works -- but all our tests are failing, which is probably bad.

In this module, we'll see how to configure our application so we can run end-to-end tests of our web application, using a lightweight, standalone database that runs as part of our test code.

## Introducing SQLite

> SQLite is a C-language library that implements a [small](https://sqlite.org/footprint.html), [fast](https://sqlite.org/fasterthanfs.html), [self-contained](https://sqlite.org/selfcontained.html), [high-reliability](https://sqlite.org/hirely.html), [full-featured](https://sqlite.org/fullsql.html), SQL database engine. SQLite is the [most used](https://sqlite.org/mostdeployed.html) database engine in the world. SQLite is built into all mobile phones and most computers and comes bundled inside countless other applications that people use every day.
>
> *from [https://sqlite.org/](https://sqlite.org/)*

In other words, SQLite is a tiny database engine that doesn't use a server: it runs in the same process as our application code, which makes it perfect for running isolated tests that still need to connect to some sort of database.

Let's see what we need to do to get our test code using SQLite instead of SQL Server.

## Using SQLite for Application Tests

First, we're going to install the SQLite provider for Entity Framework Core - **remember to install this into the Rockaway.WebApp.Tests project, not the main WebApp project**

```
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
```

Next, we're going to wire up our `TestFactory` to use SQLite instead of connecting to a real SQL server instance.

We'll wrap up our Sqlite configuration code in a `TestDatabase` class:

**Rockaway.WebApp.Tests/Data/TestDatabase.cs**

```csharp
{% include_relative {{page.examples }}Rockaway.WebApp.Tests/Data/TestDatabase.cs %}
```

> Notice that we're specifying `Mode=Memory` in our Sqlite connection string. This means we'll use a unique, temporary, in-memory database for every connection, and each database will be discarded as soon as there are no more open connections -- hence why we have a call to `sqliteConnection.OpenAsync()` in our `Connect()` method, 

Now, we can modify our `TestFactory` to replace the "real" DbContext with our Sqlite version. We don't need to explicitly remove the existing one; service registration uses the "last one wins" strategy, so calling `AddSingleton` with a new instance of `RockawayDbContext` will overwrite the previous registration:

```csharp
{% include_relative {{ page.examples }}Rockaway.WebApp.Tests/TestFactory.cs %}
```

Almost there -- but we need to make one more change here. The vast majority of database operations generated by EF Core will work with SQLite or SQL Server with no modifications, but our DatabaseVersion method uses `@@VERSION`, which is a Microsoft SQL Server feature that doesn't exist in SQLite. The equivalent feature in SQLite is the `sqlite_version()` expression, which returns a bare version number like `3.40.1`, so we're going to prepend it with `SQLite ` using the SQLite string concatenation operator `||`:

```csharp
private string DbVersionExpression {
    get {
        if (Database.IsSqlServer()) return "@@VERSION";
        if (Database.IsSqlite()) return ("'SQLite ' || sqlite_version()");
        throw new Exception("Unsupported database provider");
    }
}

// A helper property which we'll use to test the connection and return the server version.
public string ServerVersion => Database.SqlQueryRaw<string>($"SELECT {DbVersionExpression} as Value").Single();
```

## Local Development Using SQLite

If we can run our tests against SQLite, can we run our actual application with SQLite so we don't have to run a Docker image?

Sure we can, with a bit of ingenuity. We can use a configuration value to switch between SQLite and SQL Server, and set up the `DbContext` accordingly.

First, install the Sqlite package into your main application project:

```
dotnet add package Microsoft.EntityFrameworkCore.Sqlite
```

SQLite can run either as a disposable in-memory database, or as a persistent database backed by a .db file. If you're running in in-memory mode, then explicitly open a connection to your database during app initialization and don't close it; this ensures the database remains available for as long as your application is running:

```csharp
var conn = new SqliteConnection("Data Source=rockaway;Mode=Memory;Cache=Shared");
await conn.OpenAsync();
```

If you're using in-memory mode, you start with a completely empty database every time, so you'll need to create the schema and populate your database each time you run your app. Calling `Database.EnsureCreated()` will create the schema and insert any data defined via the `HasData()` methods in your `DbContext`:

```csharp
var app = builder.Build();
if (databaseProvider == "sqlite") {
	using var scope = app.Services.CreateScope();
	var db = scope.ServiceProvider.GetService<RockawayDbContext>()!;
	lock (db) db.Database.EnsureCreated();
}

// other app initialisation code happens here
app.Run();
```

 To run SQLite in filesystem mode, provide the path to the file where you want to store your data. If it doesn't exist, `SQLite` will create it for you:

```csharp
var conn = new SqliteConnection("Data Source=D:\\path\\to\\rockaway.db");
```

To keep your filesystem database in sync, you can either apply database migrations manually. Note that you still need to specify the database mode, but you need to put an extra `--` in the command line or the `dotnet ef` tooling will try to parse `database=sqlite` as a migration parameter and throw an error:

```
dotnet ef database update -- database-sqlite
```

Alternatively, you can call `db.Database.Migrate()` during application startup:

```csharp
var app = builder.Build();
if (databaseProvider == "sqlite") {
	using var scope = app.Services.CreateScope();
	var db = scope.ServiceProvider.GetService<RockawayDbContext>()!;
	db.Database.Migrate();
}
```

SQLite with in-memory mode and `EnsureCreated()` provides a really simple way to get the application up and running, play around with it, see what it can do. It's also ideal for frontend development work where you're focused on layouts and user interactions and not making lots of changes to the underlying application logic and business rules.

{: .warning }
You can't mix `EnsureCreated` and migrations in the same database -- and you shouldn't want to. `EnsureCreated()` is intended for use in testing and local development scenarios; it's like teleporting directly to the latest known state of the data model. Migrations are designed to help you manage the state of a production database over an application's entire lifecycle, which could be many, many years.

Here's the complete listing for `Program.cs` with support for running against either SQL Server or SQLite:

**Rockaway.WebApp/Program.cs:**

```csharp
{% include_relative {{ page.examples }}Rockaway.WebApp/Program.cs %}
```

## Exercises

### Testing the Artists page

There's a Razor page at `/artists` in our application which displays a list of the artists in the database.

Create a test which verifies that this page is returning the correct data.

Create a test which verifies that this page is listing artists *in alphabetical order* (defined here to be Latin1 General, accent-insensitive collation) 

### Adding Venues to the system

A venue has the following properties:

* `Name` : Unicode text, up to 100 characters, not null
* `Address`: Unicode text, up to 500 characters, not null
* `City`: Unicode text, up to 100 characters, not null
* `PostalCode`, ASCII text, up to 10 characters. Null values are allowed.
* `CountryCode`: ASCII text (not Unicode); exactly 2 characters. This is a country code as defined by [https://en.wikipedia.org/wiki/ISO_3166-2](https://en.wikipedia.org/wiki/ISO_3166-2), not null
* `WebsiteUrl`: Unicode text, up to 255 characters. Null values are allowed.
* `Telephone`: ANSI text, up to 32 characters. Null values are allowed.

Add Venue to our application:

1. Create a `Venue` class in the `Data/Entities` folder, with the properties specified above.
2. Add a migration to the project which will create the `Venues` table in the database.
3. Use the `HasData` method to seed the `Venues` table with some sample data. You'll find a CSV snippet of venue information below.
4. Add a venues property to the `RockawayDbContext`.
5. Add an endpoint in `Program.cs` to expose a list of venues at `/venues`, either using a Razor page, or by creating a new controller and view. Your choice. 
6. Add a test in `WebTests.cs` to confirm that the `/venues` endpoint exists, and returns a success status code.

**Sample Venue Information**

```csv
Name,Address,City,Country,PostalCode,Telephone,Website
The Astoria,157 Charing Cross Road,London,GB,WC2H 0EL,020 7412 3400,https://www.astoria.co.uk
Bataclan,50 Boulevard Voltaire,Paris,FR,75011,+33 1 43 14 00 30,https://www.bataclan.fr/
Columbia Theatre,Columbiadamm 9-11,Berlin,DE,10965,+49 30 69817584,https://columbia-theater.de/
Gagarin 205,Liosion 205,Athens,GR,104 45,+45 35 35 50 69,
John Dee Live Club & Pub,Torggata 16,Oslo,NO,0181 ,+47 22 20 32 32,https://www.rockefeller.no/
Stengade,Stengade 18,Copenhagen,DK,2200,+ 45 35355069,https://www.stengade.dk
Barracuda,R da Madeira 186,Porto,PT,400-433,null,null
Pub Anchor,Sveavägen 90,Stockholm,SE,113 59,+46 8 15 20 00,https://www.instagram.com/pubanchor/?hl=en
New Cross Inn,323 New Cross Road,London,GB,SE14 6AS,+44 20 8469 4382,https://www.newcrossinn.com/
```





